---
title: "hw01"
author: "Mosunov Rodion RI-411055"
date: "2024-10-18"
output:
  pdf_document:
    latex_engine: lualatex
    includes:
      in_header: header.tex
---


## Работа с данными

Загрузим набор данных в датафрейм с помощью функции `read.table()`, выведим первые 6 строк

```{r}
data.df <- read.table("rnf6080.dat.txt", header=FALSE)
print(head(data.df))
```

Посмотрим сколько у нас наблюдений и столбцов с помощью функции `dim()`

```{r}
print(dim(data.df))
```

Получим имена колонок датафрейма с помощью функции `colnames()`

```{r}
print(colnames(data.df))
```

Найдем значение 5 строки 7 столбца

```{r}
print(data.df[5, 7])
```

Напечатаем 2 строку из датафрейма

```{r}
print(data.df[2, ])
```

Следующая команда `names(data.df) <- c("year", "month", "day", seq(0,23))` присваивает название каждой колнке датафрейма: 1-3 колонка - это year, month, day, а оставшиеся имеют имя от 0 до 23

```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
```

Функции `head()` и `tail()` позволяют просмотреть первые и последние 6 строк. Последние 24 колонки представляют значения осадков по часам, нумерация колонок соответствует своему часу

```{r}
print(head(data.df))
print(tail(data.df))
```

Добавим в таблицу новую колонку `daily` и запишем в нее суммы последних 24 колонок и вывдем ее

```{r}
data.df$daily <- rowSums(data.df[, (ncol(data.df)-23):ncol(data.df)], na.rm = TRUE)
print(head(data.df['daily']))
```

Построим гистограмму по колонке `daily`.

```{r}
 hist(data.df$daily, 
       main = "daily histogram", 
       xlab = "amount of rainfall per day", 
       ylab = "amount days")
```

Поскольку в `daily` содержится сумма осадков в течении дня, то мы должны получить гистограмму, которая показывает по оси X - колчиство осадков в течении дня, а по оси Y - количество дней с соответствующим количеством осадков.\
Просмотрев набор данных, было замечено, что в нем содержатся значения -999, что является некорректыными данными. Их необоходимо исправить.\
Не зная причины возникновения таких значений, я предполагаю, что -999 означает очень маленькое значения, поэтому я заменю -999 на 0, что будет является корректным минимальным значением для осадков.

```{r}
fixed.df <- data.df
fixed.df[fixed.df < 0] <- 0
```

Создадим гистограмму с исправленными данными

```{r}
 hist(fixed.df$daily, 
       main = "daily histogram", 
       xlab = "amount of rainfall per day", 
       ylab = "amount days")
```

## Синтаксис и типизирование

Следующая команда создает массив символов

```{r}
v <- c("4", "8", "15", "16", "23", "42")
```

Следущая команда найдет максимальный символ в массиве, сравнение символов завсит от используемой кодировки и установленного локаля

```{r}
max(v)
```

Следующая команда отсортирует массив символов, также с учетом кодировки и локаля

```{r}
sort(v)
```

Следующая команда выдаст ошибку, так как она попытаемся просумировать элементы массива, однако суммировать символы нельзя

```         
sum(v)
```

Следущая команда создает вектора, содержащий элементы символьного и числового типа.\
Первая команда корректна, однако вторая - нет. Ошибка вызвана попыткой взять обратится к индексу целого числа, что является некорректной операцией.

```         
v2 <- c("5",7,12)
v2[2] + 2[3]
```

Следующий набор команд создает датафрейм со столбцами z1, z2, z3 и присваивает им значения "5", 7, 12 соответственно. Далее идет сложение элементов 2 и 3 столбца первой строки.

```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

В следующем наборе команд происходит создание списка с элементами z1, z2, z3, z4 и суммирование 2 и 4 элемента. Последняя команда является некорректной, так как обращение типа `l14[2]` возвращает не значение 2 элемента, а подспискок вида `list(z2=42)`

```         
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4]
```

## Работа с функциями и операторами

Создадим последовательность числе от 1 до 10000 с шагом 372 с помощью функции `seq()`

```{r}
print(seq(from = 1, to = 10000, by = 372))
```

Создадим последовательность чисел от 1 до 10000 содержащая 50 симовлов, используя аргумент `length.out`, который равномерно распределит числа в последовательности

```{r}
print(seq(from=1, to=10000, length.out=50))
```

Разница между двумя приведенными ниже командами заключается в том, что первая команда повторяет заданную последовательность 3 раза, а вторая команда повторяет каждый элемент последовательности 3 раза, прежде чем выведет следующий элемент

```{r}
print(rep(1:5,times=3))
print(rep(1:5, each=3))
```
